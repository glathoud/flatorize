/*
  ECMAScript implementation of "flatorize": Generate fast, flat,
  factorized ** C code ** for mathematical expressions.

  Requires: ./flatorize.js and ./flatorize_type_util.js
  
  Copyright 2013, 2014 Guillaume Lathoud
  
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
  A copy of the Apache License Version 2.0 as of February 20th, 2013
  can be found in the file ./LICENSE.TXT
*/

// -*- coding: utf-8 -*-

/*global flatorize load console*/

if ('undefined' === typeof flatorize  &&  'function' === typeof load)
    load( 'flatorize.js' );  // e.g. V8

if ('undefined' === typeof flatorize.type_util  &&  'function' === typeof load)
    load( 'flatorize_type_util.js' );  // e.g. V8

(function () {

    var FTU = flatorize.type_util;

    // ---------- Public API

    flatorize.getCodeC = flatorize_getCodeC;

    // ---------- Public API implementation

    function flatorize_getCodeC( /*object*/cfg )
    // Returns an object:
    //
    // {{{
    // { code : <array of strings (code lines)>
    //   , array_name2info : <object: <key: array name string> -> <value: object information>>
    // }
    // }}}
    // 
    //
    // Two usages:  
    // 
    // (1) In one shot, if `exprgen_fun` has no dependency, or all of them have been flatorized already
    // 
    // {{{
    // var o = flatorize.getCodeC( { name: "functionname", varstr: "a:float,b:[16 int]->c:float", exprgen: exprgen_fun } );
    // }}}
    // 
    // (2) In two steps (useful if your expression has dependencies, esp. mutual dependencies):
    // 
    // {{{
    // var switcherfun = flatorize( "a:float,b:[16 int]->c:float", exprgen_fun );
    // // ...  the remaining dependencies of `exprgen_fun` can be flatorized here ...
    // 
    // // Now we have all flatorized all dependencies of `exprgen_fun`, so we can generate code
    // var o = flatorize.getCodeC( { name: "functionname", switcher: switcherfun } );
    // }}}
    {
        var topFunName = cfg.name;   // Mandatory
        (topFunName  ||  null).substring.call.a;  // Cheap assert: Must be a string

        var js_switcher = cfg.switcher  ||  flatorize( cfg.varstr, cfg.exprgen );  // Two variants
        js_switcher.call.a;  // Cheap assert: Must be a function
        
        var js_direct   = js_switcher.getDirect  ?  js_switcher.getDirect()  :  js_switcher
        ,   fixed       = FTU.create_fixed_info( js_direct )
        ;
        
        fixed.topFunName        = topFunName;

        // Syntax definitions

        fixed.castwrap          = null;  // No cast needed because same type everywhere      

        fixed.assign_statement_code            = assign_statement_code;
        fixed.declaration_statement_code       = typed_variable_declaration_statement_code;
        fixed.line_comment_code                = line_comment_code;
        fixed.read_array_value_expression_code = read_array_value_expression_code;
        fixed.return_statement_code            = return_statement_code;
        fixed.write_array_value_statement_code = write_array_value_statement_code;

        fixed.indent = indent;

        return generateCodeC( fixed );
    }

    // ---------- Private details ----------

    function generateCodeC( /*object*/fixed )
    // Returns an object:
    //
    // {{{
    // { code : <array of strings (code lines)>
    //   , array_name2info : <object: <key: array name string> -> <value: object information>>
    // }
    // }}}
    {
        (fixed.topFunName  ||  null).substring.call.a;

        var fixed2 = Object.create( fixed ) // we will augment it a little bit with derived values, e.g. with `array_name2info`

        ,   before = []
        ,   body   = []
        ,   after  = []
        ;

        if (fixed2.single_common_array_btd)
        {
            // Dealing with arrays

            var cat = fixed2.single_common_array_btd.type;

            fixed2.sca_name = FTU.get_new_varname( fixed2, cat + '_io' );
            fixed2.sca_type = cat;
        }
        
        FTU.extract_array_info_and_count( fixed2 );

        before = [ 
            funDeclCodeC( fixed2 )
            , '/* code generated by flatorize_c.js */'
                , '{'
        ];
        
        body = FTU.fun_body_imperative_code( fixed2 );
        
        after = [ '}' ];
        
        var code = before.concat( body ).concat( after ).join( '\n' );
        
        return {
            code              : code
            , array_name2info : fixed2.array_name2info
        };
    }


    function funDeclCodeC( fixed )
    {
        var untyped_vararr    = fixed.untyped_vararr    
        ,   typed_in_var      = fixed.typed_in_var     
        ,   topFunName        = fixed.topFunName       
        ,   typed_out_varname = fixed.typed_out_varname
        ,   typed_out_vartype = fixed.typed_out_vartype
        ,   array_name2info   = fixed.array_name2info   
    
        ,   is_out_type_simple = 'string' === typeof typed_out_vartype
        ,   arr = [ ]
        ;
        arr.push( is_out_type_simple  ?  typed_out_vartype  :  'void' );
        arr.push( topFunName, '(' );

        var declArr = fixed.simple_in_vararr.map( decl_in_var );
        
        if (fixed.single_common_array_btd)
            declArr.push( '/*input and/or output array(s):*/ ' + decl( fixed.sca_name, fixed.sca_type + '*', /*notconst:*/true ) );
        
        arr.push( declArr.join( ', ' ) );

        arr.push( ')' );
        
        return arr.join( ' ' );

        function decl_in_var( varname )
        {
            var vartype = typed_in_var[ varname ];
            return decl( varname, vartype );
        }

        function decl( varname, vartype, /*?boolean?*/notconst )
        {
            var sArr = notconst  ?  []  :  [ 'const' ];
            if ('string' === typeof vartype)
            {
                sArr.push( vartype, varname );
            }
            else 
            {
                null.bug;
            } 
            
            return sArr.join( ' ' );
        }
    }
    

    // Syntax definitions
    
    function assign_statement_code( /*string*/name, /*string*/code )
    {
        return name + ' = ' + code + ';';
    }
    

    function typed_variable_declaration_statement_code( /*string*/name, /*string*/type )
    {
        return type === 'float'  ||  type === 'double'  ||  type === 'int'  ?  type + ' ' + name + ';'  :  null.unsupported;
    }

    function line_comment_code( s )
    {
        return '/* ' + s + ' */';
    }


    function read_array_value_expression_code( /*string*/array_name, /*integer*/ind )
    {
        (array_name  ||  null).substring.call.a;
        ind.toPrecision.call.a;

        return array_name + '[' + ind + ']';
    }

    function return_statement_code( /*string*/code )
    {
        return 'return ' + code + ';';
    }


    function write_array_value_statement_code( /*string*/array_name, /*integer*/ind, /*string*/code )
    {
        return array_name + '[' + ind + '] = ' + code + ';';
    }

    function indent( s )
    {
        return '  ' + s;
    }

    
})();
